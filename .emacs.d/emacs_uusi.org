#+STARTUP: overview
#+TITLE: Emacs-konfiguraatio tiedosto
#+AUTHOR: Tommi Salenius
#+EMAIL: tommisalenius@gmail.com
#+DATE: Su, 09.06.2019
#+LICENCE: GPL (2019)
#+LATEX_HEADER: \linespread{1.5}

Tämä on uusi versio tiedostosta, johon kerätään kaikki Emacsin aloituskonfiguraatiot.

* Helm
#+BEGIN_SRC emacs-lisp

  (use-package helm
    :ensure t
    :init (require 'helm-config))

#+END_SRC 

* Muuttujat
* Yleiset asetukset
** Lexical binding
Tee tästä oletus
#+BEGIN_SRC emacs-lisp

  (setq lexical-binding t)

#+END_SRC 

** Kieli
Aseta kieli siten, että oletuksenomaisesti UTF-8-merkintätapa pätee.

#+BEGIN_SRC emacs-lisp

(set-language-environment "UTF-8") (set-default-coding-systems 'utf-8)
(set-locale-environment "fi_FI.UTF-8")
(setenv "LANG" "en_US.UTF-8")
(setenv "LC_ALL" "en_US.UTF-8")
(setenv "LC_CTYPE" "en_US.UTF-8")
(setq initial-scratch-message "Toimii")
#+END_SRC 

#+RESULTS:
: Toimii

** Käyttäjätiedot
#+name: user-info
| Muuttuja         | Arvo                      |
|------------------+---------------------------|
| sähköpostiosoite | "tommisalenius@gmail.com" |
#+BEGIN_SRC emacs-lisp :exports code :var user-info=user-info :results list
(setq sähköpostiosoite "tommisalenius@gmail.com")
#+end_SRC

#+RESULTS:
: - tommisalenius@gmail.com

** Työkalurivi ja valikkorivi
Piilota työkalurivi oletusarvoisesti. Valikkoriviä ei tarvitse piilottaa, koska
Macissa se on sijoitettuna automaattisesti ikkunan yläpuolella sijaitsevaan
palkkiin jota ei voi poistaa.
#+BEGIN_SRC emacs-lisp

(tool-bar-mode -1)

#+END_SRC 
** Aloitusbuffer
Aseta oletusarvoisesti niin, että Emacsin default-aloitusbufferi
ei pomppaa kuvaan kun ohjelma avataan. Sen sijaan scratch-bufferi toimii
avausikkunana.

#+BEGIN_SRC emacs-lisp

(setq inhibit-startup-screen t)

#+END_SRC 
** Rivin highlightaus
Kytkin tämän pois päältä, koska se usein häiritsee enemmän kuin auttaa
(esim. smartparens-moden kanssa turhahko).
#+BEGIN_SRC emacs-lisp

  (global-hl-line-mode nil)

#+END_SRC 

** Meta + X -substituutti (Helm/Smex)
Alt + x -yhdistelmä on ergonomisesti aivan karsea. Tee näppäinyhdistelmä, jossa
voidaan saada helpommin menu / valikko / funktiovalikko käyttöön. 
Käytän tässä counsel-nimistä autocomplete-työkalua. 

#+BEGIN_SRC emacs-lisp
  ;; (define-key key-translation-map (kbd "åe") (kbd "M-x"))
  ;; (define-key key-translation-map (kbd "åE") (kbd "M-X"))
#+END_SRC 

** Rivinumerot
Emacsissa ei ole oletuksena rivinumeroita. Tämän avulla ne näkyvät.

#+BEGIN_SRC emacs-lisp

(global-linum-mode t)

#+END_SRC 

** Varmuuskopiot / backupit
Oletusarvoisesti kaikki backup-tiedostot menevät samaan kansioon kuin alkuperäis-
tiedostotkin. Luo kaikille tiedostoille yhtenäinen backup-kansio tilanteen helpottamiseksi.

#+BEGIN_SRC emacs-lisp

(setq backup-directory-alist '(("." . "/Users/tommi/.emacs.d/backup")))

#+END_SRC 

** Merkkiääni
Hiljennä editoreissa tyypillisesti oleva merkkiääni, joka soi esim. kun kursori
on jo rivin alussa/lopussa ja yrittää siirtyä siitä eteenpäin.

#+BEGIN_SRC emacs-lisp

(setq ring-bell-function 'ignore)

#+END_SRC 

** Näytä kellonaika
Tämän ansiosta kellonaika ja pvm näkyvät helposti. Katso vielä formatointi
uusiksi kunnolla (24-h ajanotto jne).

#+BEGIN_SRC emacs-lisp

(display-time-mode 1)
(setq display-time-24hr-format t)

#+END_SRC 

** Kyllä ja ei -kysymykset
Aseta niin, että voit vastata yes or no -tyylisiin kyssäreihiin vain y tai n. Helpottaa elämää.

#+BEGIN_SRC emacs-lisp

(fset 'yes-or-no-p 'y-or-n-p)

#+END_SRC 

** Terminaali / shell
Aseta oletusarvoisesti zsh terminaaliksi, joka avataan kun käsky annetaan.

#+BEGIN_SRC emacs-lisp

(setq explicit-shell-file-name "/bin/zsh")

#+END_SRC 

** Kursori
Aseta kursorin väri fiksummaksi kuin oletusarvo. Voit vaihtaa värin
laittamalla heksadesimaalisen värikoodin muodossa _hxväri_, jossa väri
voi olla mikä tahansa kuten punainen, limenvihreä jne; abbrev-mode
korjaa tämän jälkeen värin heksadesimaalinumeroksi

#+BEGIN_SRC emacs-lisp

(set-cursor-color "#c8a2c8")

#+END_SRC 

** Autocomplete
Pistä popup-valikko funktioille pystyyn.
#+BEGIN_SRC emacs-lisp

  (use-package company
    :ensure t
    :init
    )

  (use-package company
      :ensure t
      :init
      (global-company-mode 1)
      :config
      (setq company-idle-delay 0)
      (setq company-minimum-prefix-length 3))
  ;; (require 'company)
  ;; (setq company-idle-delay 0)

  ;; (add-hook 'emacs-lisp-mode-hook 'company-mode)
  ;; (add-hook 'lisp-interactive-mode-hook 'company-mode)
  ;; (add-hook 'python-mode-hook 'company-mode)
  ;; (add-hook 'ess-mode-hook 'company-mode)
  ;; (add-hook 'clojure-mode-hook 'company-mode)
  ;; (add-hook 'cider-mode-hook 'company-mode)
#+END_SRC 

** Tallennus
#+BEGIN_SRC emacs-lisp

(setq-default require-final-newline nil)

#+END_SRC 

** Automaattinen sisennys / indentointi
Saatu Emacs-wikistä. Ei toimi ainakaan Pythonin kanssa juuri niin kuin pitää,
jos yrittää saada uuden sisennyksen valmiin sisennyksen alle (esim. uusi if-lause
toisen if-lauseen sisälle.)
#+BEGIN_SRC emacs-lisp

(dolist (command '(yank yank-pop))
   (eval `(defadvice ,command (after indent-region activate)
            (and (not current-prefix-arg)
                 (member major-mode '(emacs-lisp-mode lisp-mode
                                                      clojure-mode    scheme-mode
                                                      haskell-mode    ruby-mode
                                                      rspec-mode      python-mode
                                                      c-mode          c++-mode
                                                      objc-mode       latex-mode
                                                      plain-tex-mode  ess-r-mode))
                 (let ((mark-even-if-inactive transient-mark-mode))
                   (indent-region (region-beginning) (region-end) nil))))))

#+END_SRC 

** Warningit
#+BEGIN_SRC emacs-lisp

  ;; (yasnippet backquote-change) to ‘warning-suppress-types’

#+END_SRC 

** Apit
#+BEGIN_SRC emacs-lisp

  (load "apikeys.el")

#+END_SRC 

** Tiedostonpäätteet / loppu
#+BEGIN_SRC emacs-lisp :lexical t

  ;; (add-to-list 'auto-mode-alist '(("\\.pl\\'" . prolog-mode)
				  ;; ("\\.coco\\'" . coconut-mode)
				  ;; ("\\.coc\\'" . coconut-mode)
				  ;; ("\\.coconut\\'" . coconut-mode))
	       ;; )
#+END_SRC 

** Näppäimet
#+BEGIN_SRC emacs-lisp :lexical t
  (global-set-key (kbd "C-ä 7") (lambda () (insert "\\")))
  (global-set-key (kbd "C-ä 2") (lambda () (insert "@")))
  (global-set-key (kbd "C-ä 4") (lambda () (insert "$")))









#+END_SRC 

* Teema
Valitse teematiedosto, jota haluat käyttää. 

#+BEGIN_SRC emacs-lisp

  ;; (load-theme 'manoj-dark)
  (load-theme 'zenburn)

#+END_SRC 
* Painikkeet
#+BEGIN_SRC emacs-lisp :lexical t

  (defmacro keytrans (key1 key2)
      `(define-key key-translation-map (kbd ,key1) (kbd ,key2)))

  (keytrans "M-(" "{")
  (keytrans "M-)" "}")
  (keytrans "M-8" "[")
  (keytrans "M-9" "]")
  (keytrans "M-2" "@")
  (keytrans "M-4" "$")
  (keytrans "M-7" "|")
  (keytrans "M-/" "\\")


#+END_SRC 

* Evil
** Use-package
#+BEGIN_SRC emacs-lisp :noweb yes

  (use-package evil
    :ensure t
    :init

    (defmacro def-avain (nimi moodi)
      "Yleistyökalu, jonka avulla käyttäjä voi luoda funktioita, jotka asettavat
      puolestaan pikanäppäinkomennon tietyn tilan funktioille. NIMI on funktion nimi,
      jonka makro palauttaa, MOODI on puolesta mode, jolle funktio voi luoda näppäinyhdistelmän."
      `(defun ,nimi (key func)
	 (define-key ,moodi (kbd key) func)))

    (defmacro luo-avain (moodi key func)
      `(add-hook (quote ,(intern (concat (symbol-name moodi) "-hook")))
		   (lambda () (evil-define-key 'normal ,(intern (concat (symbol-name moodi) "-map")) (kbd ,key) (quote ,func)))))


    (defmacro kirjoita (merkki)
      `(lambda ()
	 (interactive)(insert ,merkki)))

    (def-avain evil/ins evil-insert-state-map)
    (def-avain evil/n evil-normal-state-map)
    (def-avain evil/i evil-insert-state-map)
    (def-avain evil/m evil-motion-state-map)
    (def-avain evil/v evil-visual-state-map)
    (def-avain company/a company-active-map)

    :config
    (evil-mode 1)

    <<bufferit-ja-ikkunat>>
    <<etsimis-tools-evil>>

    (evil/n "C-ö" 'comment-line)
    (evil/n "ål" 'eval-last-sexp)
    (evil/n "åL" 'eval-last-sexp-and-replace-it-by-result)
    (evil/n "å TAB" 'indent-region)

    (evil/n "ånm" 'bookmark-set)
    (evil/n "gm" 'helm-bookmarks)

    (evil/i "C-ö" 'evil-normal-state)
    <<evil-erikoismerkit>>
    <<smartparens-evil>>

    ;; Hydrat

    (evil/n "åg" 'magit-hydra/body)
    (evil/n "åt" 'shell-hydra/body)
    <<keyboard-macro-hydra-blokki>>
    (evil/n "q" 'keyboard-macro-hydra/body)

    ;; Major mode -spesifit evil-pikanäppäimet
    <<org-evil>>
    <<python-evil>>
    <<R-ess-evil>>

    ) 
#+END_SRC 
** Bufferien ja ikkunoiden hallinta
#+NAME: bufferit-ja-ikkunat
#+BEGIN_SRC emacs-lisp :lexical t :tangle no
  (evil/n "§" 'end-of-line)
  (evil/n "zj" 'evil-scroll-down)
  (evil/n "zk" 'evil-scroll-up)

  (evil/n "ås" 'save-buffer)
  (evil/n "öb" 'counsel-ibuffer)
  (evil/n "öä" 'kill-this-buffer)

  (evil/n "öd" 'dired)
  (evil/n "gf" 'helm-find-files)
  (evil/n "ää" 'evil-execute-macro)

  (evil/n "öwh" 'split-window-right)
  (evil/n "öwv" 'split-window-below)
  (evil/n "ökt" 'delete-window)
  (evil/n "öka" 'delete-other-windows)
  (evil/n "öö" 'ace-window)

  (evil/n "åc" 'capitalize-word)

  (defun tomreal/jump-scratch-buffer-or-back
      ()
    (interactive)
    (if (equal (buffer-name) "*scratch*")
	(progn (evil-switch-to-windows-last-buffer)
	       (print (concat  "Going to buffer " (buffer-name))))
      (progn (print "Going to buffer *scratch*")
	     (switch-to-buffer "*scratch*"))))
  (evil/n "ös" 'tomreal/jump-scratch-buffer-or-back)
#+END_SRC 

#+RESULTS: bufferit-ja-ikkunat
: tomreal/jump-scratch-buffer-or-back

** Smartparens
#+NAME: smartparens-evil
#+BEGIN_SRC emacs-lisp :lexical t :tangle no
  (evil/i "å SPC" 'sp-forward-sexp)

  (evil/n ",j" 'sp-join-sexp)
  (evil/n ",s" 'sp-forward-slurp-sexp)
  (evil/n ",S" 'sp-backward-slurp-sexp)
  (evil/n ",b" 'sp-forward-barf-sexp)
  (evil/n ",B" 'sp-backward-barf-sexp)
  (evil/n ",u" 'sp-unwrap-sexp)
  (evil/n ",k" 'sp-kill-sexp)
  (evil/n "D" 'sp-kill-hybrid-sexp)
  (evil/n ",K" 'sp-backward-kill-sexp)
  (evil/n ",ww" 'sp-wrap-round)
  (evil/n ",t" 'sp-transpose-sexp)
  (evil/n ",T" 'sp-transpose-hybrid-sexp)
  (evil/n ",a" 'sp-beginning-of-sexp)
  (evil/n ",l" 'sp-end-of-sexp)
  (evil/n ",e" 'sp-emit-sexp)

  (evil/v ",ww" 'sp-wrap-round)
  (evil/n ",wc" 'sp-wrap-curly)
  (evil/v ",wc" 'sp-wrap-curly)
  (evil/n ",ws" 'sp-wrap-square)
  (evil/v ",ws" 'sp-wrap-square)
#+END_SRC 

** Projectile
#+BEGIN_SRC emacs-lisp :lexical t

  (evil/n "åpgp" 'projectile-switch-project)
  (evil/n "åpgf" 'projectile-find-file)
  (evil/n "åpgg" 'projectile-grep)

#+END_SRC 

** Org
#+NAME: org-evil
#+BEGIN_SRC emacs-lisp :lexical t :tangle no
  (luo-avain org-mode "åre" org-edit-src-code)
  (luo-avain org-src-mode "ås" org-edit-src-exit)
  (luo-avain org-mode "åx" org-export-dispatch)
  (luo-avain org-mode "årr" org-ctrl-c-ctrl-c)
  (luo-avain org-mode "åf" org-meta-hydra/body)
#+END_SRC 

** Python
#+NAME: python-evil
#+BEGIN_SRC emacs-lisp :lexical t :tangle no
  (luo-avain python-mode "åd" elpy-doc)
  (luo-avain python-mode "åp" python-projekti-hydra/body)
  (luo-avain python-mode "årr" elpy-shell-send-buffer)
  (luo-avain python-mode "årö" elpy-shell-send-buffer-and-go)
  (evil-define-key 'visual python-mode-map "år" 'elpy-shell-send-region-or-buffer)
  (luo-avain python-mode "ör" elpy-shell-switch-to-shell)
  (evil-define-key 'normal inferior-python-mode-map "ör" 'evil-switch-to-windows-last-buffer)
  (luo-avain python-mode "åi" python-indentation-hydra/body)




#+END_SRC 

** ESS
   #+NAME: R-ess-evil
#+BEGIN_SRC emacs-lisp :lexical t :tangle no
  (luo-avain ess-mode "årr" ess-eval-region-or-function-or-paragraph-and-step)
  (luo-avain ess-mode "årl" ess-load-file)
  (luo-avain ess-mode "åd" ess-display-help-on-object)
#+END_SRC 

** Clojure
#+BEGIN_SRC emacs-lisp :lexical t

  (defun cider-evaluoi-viimeinen-sexp
      (sexp)
    (interactive "p")
    (save-excursion
      (right-char 1)
      (cider-eval-last-sexp-to-repl sexp)
      ))

  (defun cider-evaluoi-ja-avaa-ikkuna
      ;; (optional & args)
      ()
    (interactive)
    (progn 
      (cider-eval-buffer (buffer-name))
      (split-window-below)))


  ;; (luo-avain clojure-mode "årr" cider-evaluoi-ja-avaa-ikkuna)
  (luo-avain clojure-mode "årr" cider-eval-buffer)
  (luo-avain clojure-mode "årl" cider-evaluoi-viimeinen-sexp)
  (luo-avain clojure-mode "årtt" cider-test-run-test)
  (luo-avain clojure-mode "årtn" cider-test-run-ns-tests)
  (luo-avain clojure-mode "årtp" cider-test-run-project-tests)
  (luo-avain clojure-mode "åd" cider-doc)
  ;; (luo-avain clojure-mode "åf" hydra-cljr-help-menu/body)
  (luo-avain clojure-mode "ör" cider-switch-to-repl-buffer)

  ;;;;;;;;;;;;;;;
  ;; REPL

  (luo-avain cider-repl-mode "åd" cider-doc)
  (luo-avain cider-repl-mode "åc" cider-repl-clear-buffer)
  (luo-avain cider-repl-mode "ör" cider-switch-to-last-clojure-buffer)

#+END_SRC 

** Scala
#+BEGIN_SRC emacs-lisp :lexical t

  (luo-avain scala-mode "årr" ammonite-term-repl-send-buffer)
  (luo-avain scala-mode "årf" ammonite-term-repl-send-defun)
  (add-hook 'scala-mode-hook
	    (lambda () (evil-define-key 'visual scala-mode-map "årr" 'ammonite-term-rpel-send-region)))

#+END_SRC 

** Erikoismerkit
#+NAME: evil-erikoismerkit
#+BEGIN_SRC emacs-lisp :lexical t :tangle no
  (evil/i "å." (kirjoita "å"))
  (evil/i "åi" (kirjoita "|"))
  (evil/i "¨s" (kirjoita "\\"))
  (evil/i "¨d" (kirjoita "$"))
  (evil/i "å2" (kirjoita "@"))
#+END_SRC 

** LSP
#+BEGIN_SRC emacs-lisp :lexical t

  (evil/n "ådfd" 'xref-find-definitions-other-window)
  (evil/n "ådfr" 'xref-find-references)
  (evil/n "ådpd" 'lsp-ui-peek-find-definitions)
  (evil/n "ådpr" 'lsp-ui-peek-find-references)


#+END_SRC 

** Apu- ja etsimistyökalut
#+NAME: etsimis-tools-evil
#+BEGIN_SRC emacs-lisp :lexical t :tangle no
  (use-package smex
    :ensure t)
  (evil/n "åhf" 'counsel-describe-function)
  (evil/n "åhv" 'counsel-describe-variable)
  (evil/n "åhk" 'describe-key)
  (evil/n "åhl" 'select-jargon)
  (evil/n "åe" 'helm-M-x)
  (evil/i "åe" 'helm-M-x)
  (evil/v "åe" 'helm-M-x)
  (evil/n "C-s" 'swiper)
#+END_SRC 

** Snippetit
#+BEGIN_SRC emacs-lisp :lexical t

  (evil/n "åns" 'yas-new-snippet)

#+END_SRC 

* Magit
#+BEGIN_SRC emacs-lisp :lexical t

  (use-package magit
    :ensure t)

#+END_SRC 

* Hydra
** Use-package
#+BEGIN_SRC emacs-lisp :noweb yes

  (use-package hydra
    :init

    <<magit-hydra-blokki>>
    <<shell-hydra-blokki>>
    <<skrollaus-hydra-blokki>>
    <<org-meta-hydra-blokki>>
    <<helm-projektiili-hydra-blokki>>
    <<python-projekti-hydra-blokki>>

    )

#+END_SRC 

** Keyboard macro
#+name: keyboard-macro-hydra-blokki
#+BEGIN_SRC emacs-lisp :lexical t :tangle no

  (defhydra keyboard-macro-hydra (:color pink :hint nil)
    "
  ^Peruskomento^             ^Makrojen hallinta^
  ^^^^^^^^^^^^^^--------------------------------------
  _o_: aloita makro          _r_: toista viimeisin makro
  _e_: lopeta makro          _n_: nimeä viimeisin makro
  _s_: aseta counter         _p_: pasteta viimeisin makro
  _c_: counter + 1
  "
    ("o" start-kbd-macro :exit t)
    ("e" end-kbd-macro :exit t)
    ("s" kmacro-set-counter :exit t)
    ("c" kmacro-add-counter :exit t)
    ("r" call-last-kbd-macro)
    ("n" name-last-kbd-macro)
    ("p" insert-kbd-macro :exit t)
    ("q" nil "peruuta" :color :blue))

#+END_SRC 

** Magit
#+name: magit-hydra-blokki
#+BEGIN_SRC emacs-lisp :lexical t :tangle no
  (defhydra magit-hydra (:color pink
				  :hint nil)
      "
  ^Branch^         ^Versionhallinta^
  ^^^^^^^-----------------------------------
  _s_: status       _a_: stageta kaikki muutokset
  _i_: init         _f_: stageta tietty tiedosto
  _o_: checkout     _c_: commitoi muutokset
  ^^                _pl_: pullaa branchista
  ^^                _psh_: pushaa Githubiin tms
  "
      ("s" magit-status :exit t)
      ("i" magit-init)
      ("o" magit-checkout)
      ("a" magit-stage-modified)
      ("f" magit-stage-file)
      ("c" magit-commit :exit t) ;; Jotta voi kirjoittaa normaalisti
      ("pl" magit-pull-from-upstream)
      ("psh" magit-push-current-to-upstream :exit t)
      ("q" nil "peruuta" :color blue))
#+END_SRC 

** Shell
#+NAME: shell-hydra-blokki
#+BEGIN_SRC emacs-lisp :lexical t :tangle no
  (defhydra shell-hydra (:color pink :hint nil)
	"
    ^Terminaalit^     ^Tulkit^
    ------------------------------------------------
    _e_: Eshell       _p_: iPython
    _t_: iTerm        _r_: R
    "
	("e" eshell :exit t)
	("t" term :exit t)
	("p" run-python :exit t)
	("r" R :exit t)
	("q" nil "peruuta" :color blue))

#+END_SRC 

** Org
*** Metanäppäimet
#+NAME: org-meta-hydra-blokki
#+BEGIN_SRC emacs-lisp :lexical t :tangle no
  (defhydra org-meta-hydra (:color pink :hint nil)
	"
    Liiku
    -----
    _j_: alas
    _k_: ylös
    _h_: vasen
    _l_: oikea
    _r_: aja koodi
    "
	("j" org-metadown)
	("k" org-metaup)
	("h" org-shiftmetaleft)
	("l" org-shiftmetaright)
	("r" org-ctrl-c-ctrl-c)
	("q" nil "exit" :color blue))
#+END_SRC 

** Projectile
*** Helm-versio
#+NAME: helm-projektiili-hydra-blokki
#+BEGIN_SRC emacs-lisp :lexical t :tangle no
  (defhydra helm-projektiili-hydra (:color pink :hint nil :exit t)
	"
    Projektien hallinta
    -------------------
    _p_: etsi projekti
    _f_: etsi tiedosto
    _g_: etsi tiettyä regexiä
    "
	("p" helm-projectile-switch-project)
	("f" helm-projectile-find-file)
	("g" helm-projectile-grep)
	("q" nil "exit" :color blue)
	)
#+END_SRC 

** Clojure-refactoring
#+BEGIN_SRC emacs-lisp :lexical t

  (defhydra clojure-refactoring-hydra (:color pink :hint nil :exit t)
    "
     ^Valitse refaktorointi^
     ------------------------------------------
     _r_: lisää riippuvuus
     _m_: lisää puuttuva paketti ns:n pohjalta
     _v_: luo ekspressiosta muuttuja
     _tf_: muunna -> muotoon
     _tl_: muunna ->> muotoon
     "

    ("r" cljr-add-require-to-ns)
    ("m" cljr-add-missing-libspec)
    ("v" cljr-extract-def)
    ("tf" clojure-thread-first-all :exit nil)
    ("tl" clojure-thread-last-all :exit nil)
    ("q" nil "exit" :color blue))

#+END_SRC 

** Python
*** Indentointi
#+BEGIN_SRC emacs-lisp :lexical t

  (defhydra python-indentation-hydra (:color pink :hint nil)
    "
  ^Indentointimoodi^
  ^^^^^^^^^^^^^^^^^^
  _h_: sisennä
  _l_: ulonna
  _v_: visual mode
  _g_: poistu
  "
    ("h" elpy-nav-indent-shift-left)
    ("l" elpy-nav-indent-shift-right)
    ("v" evil-visual-char)
    ("g" nil :exit t)
    ("q" nil :exit t))

#+END_SRC 

*** Virtuaaliympäristöt ja projektit
#+name: python-projekti-hydra-blokki
#+BEGIN_SRC emacs-lisp :lexical t :tangle no
  (defhydra python-projekti-hydra (:color pink :hint nil)
      "
  ^Virtuaaliympäristö
  -------------------------------
  _v_: valitse ympäristö
  _a_: aktivoi projektiin sidottu
  _d_: deaktivoi nykyinen
  "
      ("v" (conda-env-activate ((lambda () (interactive)
				  (ido-completing-read "Valitse conda-ympäristö: " (conda-env-candidates))))))
      ("a" conda-env-activate)
      ("d" conda-env-deactivate)
      ;; ("c" pyvenv-create)
      ("q" nil "exit" :color blue))
#+END_SRC 

#+RESULTS: python-projekti-hydra-blokki
: python-projekti-hydra/body

** Dired
#+BEGIN_SRC emacs-lisp :lexical t

  (defhydra dired-info-hydra (:color pink :hint nil)
    "
  _f_: mene sisälle    _+_: luo kansio
  _m_: merkitse        _!_: aja shell-komento
  _u_: poista merkintä
  _U_: poista merkintä kaikilta
  _d_: merkitse poistettavaksi
  _x_: poista merkityt
  "
    ("f" dired-find-file)
    ("m" dired-mark)
    ("u" dired-unmark)
    ("U" dired-unmark-all-files)
    ("d" dired-flag-file-deletion)
    ("x" dired-do-flagged-delete)
    ("+" dired-create-directory)
    ("!" dired-do-shell-command)
    ("quit" nil "quit" :color blue))

#+END_SRC 

** Muut työkalut
*** Skrollaus
#+NAME: skrollaus-hydra-blokki
#+BEGIN_SRC emacs-lisp :lexical t
  (defhydra skrollaus-hydra (:color pink :hint nil)
      "
  Skrollaa^
  ----------------
  _j_: alas   _k_: ylös
  "
      ("j" evil-scroll-down)
      ("k" evil-scroll-up)
      ("c" nil "peruuta" :color blue))
#+END_SRC 

* Smartparens
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t

    :config

    (smartparens-global-mode 1)
    (show-paren-mode 1)

    ;; Chris Allenille kredit tästä
    ;; Poista Lisp-moodeilta '-merkin ja `-merkin käyttö
    ;; pareina, joiden vastine luodaan automaattisesti
    (sp-with-modes sp--lisp-modes
      (sp-local-pair "'" nil :actions nil) ; disable ', it's the quote character!
      (sp-local-pair "`" "'" :when '(sp-in-string-p))) ; also only use the pseudo-quote inside strings where it serve as a hyperlink

    (sp-with-modes '(org-mode)
      (sp-local-pair "$" "$")
      (sp-local-pair "$$" "$$"))

    (sp-with-modes '(python-mode)
      (sp-local-pair "\"\"\"" "\"\"\"")
      (sp-local-pair "np.array([" "])" :trigger "np.array(")
      (sp-local-pair "(" ")")
      (sp-local-pair "[" "]")
      (sp-local-pair "{" "}")
      (sp-local-pair "print(" ")")
      (sp-local-pair "list(map(" "))" :trigger "map(")
      (sp-local-pair "list(filter(" "))" :trigger "filter("))

    (sp-with-modes '(scala-mode)
      (sp-local-pair "/*" "*/")
      (sp-local-pair "match {" "}" :trigger "match ")
      (sp-local-pair "for {" "} yield " :trigger "for y")
      (sp-local-pair "Option[" "]" :trigger "Option"))

    (sp-with-modes '(sql-mode)
      (sp-local-pair "/*" "*/")
      (sp-local-pair "case" "end" :trigger "case "))

    (sp-with-modes '(c-mode c++-mode)
      (sp-local-pair "/*" "*/"))

  )

#+END_SRC 

* Swiper
#+BEGIN_SRC emacs-lisp

  (use-package swiper
    :ensure t)

#+END_SRC 

* Key-Chord
** Use-package
#+BEGIN_SRC emacs-lisp :noweb yes

  (use-package key-chord
    :ensure t
    :init

    (defun evaluoi-ja-tallenna-tulos-leikepöydälle
	(ssexp)
      (interactive "P")
      (thread-first ssexp
	(eval-last-sexp)
	(string)
	(kill-new)
	))

    :config

    (key-chord-mode 1)

    (key-chord-define-global "eö" 'end-of-line)
    (key-chord-define-global "öa" (lambda (x) (interactive "P")
				    (progn (insert "[]") (backward-char))))
    (key-chord-define-global "äa" (lambda (x) (interactive "P")
				    (progn (insert "{}") (backward-char))))
    (key-chord-define-global "öx" (lambda (x) (interactive "P")
				    (insert "\\")))

    ;; Hydrat
    (key-chord-define-global "zx" 'skrollaus-hydra/body)

    ;; org-mode
    (key-chord-define org-mode-map "yu" 'org-meta-hydra/body)

    ;; R:n lokaalit
    ;; <<ess-keychord>>
    ) 


#+END_SRC 

* Acejump
* Yasnippet
#+BEGIN_SRC emacs-lisp :lexical t

  (use-package yasnippet
    :ensure t
    :init
    (add-to-list 'warning-suppress-types '(yasnippet backquote-change))
  )

#+END_SRC 

* which-key
#+BEGIN_SRC emacs-lisp :lexical t

  (use-package which-key
    :ensure t
    :init
    (which-key-mode 1)
    )

#+END_SRC 

* Projectile
#+BEGIN_SRC emacs-lisp :lexical t

  (use-package projectile
    :ensure t
    :config
    (projectile-mode 1)
    (use-package helm-projectile
      :ensure t
      :config
      )
    (helm-projectile-on)
    )

#+END_SRC 

* Eshell
** Pikanäppäimet
#+BEGIN_SRC emacs-lisp :lexical t

  (defun eshell/clear ()
    "Clear the eshell buffer."
    (interactive)
    (let ((inhibit-read-only t))
      (eshell-send-input)
      (erase-buffer)))

  (evil-define-key 'normal eshell-mode-map "åc" 'eshell/clear)
  (evil-define-key 'normal eshell-mode-map "åc" 'eshell/clear)


#+END_SRC 

** Kustomointi
    
#+begin_src emacs-lisp
  (require 'dash)
  (require 's)

  (defmacro with-face (STR &rest PROPS)
    "Return STR propertized with PROPS."
    `(propertize ,STR 'face (list ,@PROPS)))

  (defmacro esh-section (NAME ICON FORM &rest PROPS)
    "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
    `(setq ,NAME
	   (lambda () (when ,FORM
		   (-> ,ICON
		      (concat esh-section-delim ,FORM)
		      (with-face ,@PROPS))))))

  (defun esh-acc (acc x)
    "Accumulator for evaluating and concatenating esh-sections."
    (--if-let (funcall x)
	(if (s-blank? acc)
	    it
	  (concat acc esh-sep it))
      acc))

  (defun esh-prompt-func ()
    "Build `eshell-prompt-function'"
    (concat esh-header
	    (-reduce-from 'esh-acc "" eshell-funcs)
	    "\n"
	    eshell-prompt-string))


  (esh-section esh-dir
	       "\xf07c"  ;  (faicon folder)
	       (abbreviate-file-name (eshell/pwd))
	       '(:foreground "gold" :bold ultra-bold :underline t))

  (esh-section esh-git
	       "\xe907"  ;  (git icon)
	       (magit-get-current-branch)
	       '(:foreground "pink"))

  (esh-section esh-python
	       "\xe928"  ;  (python icon)
	       pyvenv-virtual-env-name)

  (esh-section esh-clock
	       "\xf017"  ;  (clock icon)
	       (format-time-string "%H:%M" (current-time))
	       '(:foreground "forest green"))

  ;; Below I implement a "prompt number" section
  (setq esh-prompt-num 0)
  (add-hook 'eshell-exit-hook (lambda () (setq esh-prompt-num 0)))
  (advice-add 'eshell-send-input :before
	      (lambda (&rest args) (setq esh-prompt-num (incf esh-prompt-num))))

  ;; Laitetaan tämä sellaisenaan uinumaan nyt
  ;; (esh-section esh-num
	       ;; "\xf0c9"  ;  (list icon)
	       ;; (number-to-string esh-prompt-num)
	       ;; '(:foreground "brown"))

  ;; Separator between esh-sections
  (setq esh-sep " | ")  ; or "   "

  ;; Separator between an esh-section icon and form
  (setq esh-section-delim " ")

  ;; Eshell prompt header
  (setq esh-header "\n ")  ; or "\n┌─"

  ;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
  ;; your login, these can be the same.
  (setq eshell-prompt-regexp " λ ")   ; or "└─> "
  (setq eshell-prompt-string " λ ")   ; or "└─> "

  ;; Choose which eshell-funcs to enable
  (setq eshell-funcs
	(list
	 esh-dir
	 esh-git
	 esh-python
	 esh-clock
	 ;; esh-num
	 ))

  ;; Enable the new eshell prompt
  (setq eshell-prompt-function 'esh-prompt-func)

#+END_SRC 

#+RESULTS:
: esh-prompt-func
* org
#+BEGIN_SRC emacs-lisp :lexical t

  (use-package org
    :ensure t
    :init

    ;; Tuetut
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((python . t)
       (ipython . t)
       (R . t)
       (sqlite . t)
       (C . t)
       (java . t)
       (prolog . t)
       (latex . t)
       (matlab . t)
       (haskell . t)
       (emacs-lisp . t)
       (js . t)))

    ;; Aseta LaTeX-kaavojen highlightaus
    (setq org-highlight-latex-and-related '(latex script entitites))

    ;; Älä kysy näihin liittyen koodin evaluoimista
    (defun my-org-confirm-babel-evaluate (lang body)
      (not (member lang '("python" "clojure" "sh" "java" "R" "latex" "prolog" "haskell"
			  "js" "emacs-lisp" "matlab"))))

    (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)


    ;; Tiedoston kääntäminen toiseen formaatiin

    )



#+END_SRC 

* Python
#+BEGIN_SRC emacs-lisp :lexical t

  (use-package python-mode
    :ensure t
    :custom (elpy-rpc-backend "jedi")
    :init
    (setq python-shell-interpreter "ipython3")

    (use-package conda
      :ensure t
      :init
      (setq conda-anaconda-home (expand-file-name "/Applications/anaconda3"))
      (setq conda-env-home-directory (expand-file-name "/Applications/anaconda3"))

      (conda-env-initialize-interactive-shells)
      ;; if you want eshell support, include:
      (conda-env-initialize-eshell)
      ;; if you want auto-activation (see below for details), include:
      ;; (conda-env-autoactivate-mode t) ; Käytä tätä kun ymmärrät miten paketti toimii

      ;; Jotta shell ei printtaisi liian monta kertaa argumentteja
      (setq python-shell-interpreter-args "--simple-prompt -i")

      )

    (use-package ipython-shell-send
      :ensure t)
    :config
    (elpy-enable)
    ;; (virtualenv-minor-mode 1)
    (pyvenv-mode 1)
      )

  (use-package pyvenv
	:ensure t
	:config
	(setq virtuaaliympäristöjen-sijoituspaikka "/Applications/anaconda3/envs")
	(setenv "WORKON_HOME" virtuaaliympäristöjen-sijoituspaikka)
	(pyvenv-mode 1)
	(pyvenv-tracking-mode 1)

	(defun valitse-virtuaaliympäristö ()
	  (interactive)
	  (ido-completing-read "Valitse ympäristö: " (pyvenv-virtualenv-list)))
	)
#+END_SRC 

* Clojure
#+BEGIN_SRC emacs-lisp :lexical t
  ;; Aseta tämä nil jos repl ei käynnisty
  ;; (setq cljr-inject-dependencies-at-jack-in t)

  (use-package clojure-mode
    :ensure t
    :defer t

    :init
    ;; (require 'clj-refactor)
    ;; (add-hook 'clojure-mode-hook (lambda () (clj-refactor-mode 1)))
    (add-hook 'clojure-mode-hook (lambda () (company-mode 1)))
    (add-hook 'cider-mode-hook #'company-cider-make-exclusive)

    ;; (company-mode 1)
    )

#+END_SRC 
* Haskell
#+BEGIN_SRC emacs-lisp :lexical t

  (require 'haskell-interactive-mode)
  (require 'lsp)
  (require 'lsp-haskell)
  (require 'haskell-process)
  (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
  (add-hook 'haskell-mode-hook #'lsp)
  (add-hook 'haskell-literate-mode-hook #'lsp)
#+END_SRC 

* Scheme
#+BEGIN_SRC emacs-lisp :lexical t

;; Chicken-versio Schemesta
(setq scheme-program-name "csi -:c")

#+END_SRC 

* LSP
#+BEGIN_SRC emacs-lisp :lexical t

  (use-package lsp-mode
    ;; :defer t
    :hook (python-mode . lsp)
    (scala-mode . lsp)
    (lsp-mode . lsp-lens-mode)
    ;; :commands lsp

    )

  (use-package flycheck
    :init (global-flycheck-mode))

  ;; (use-package lsp-scala
    ;; :load-path "~/path/to/lsp-scala"
    ;; :./coursier bootstrap \
  ;; --java-opt -Xss4m \
  ;; --java-opt -Xms100m \
  ;; --java-opt -Dmetals.client=emacs \
  ;; org.scalameta:metals_2.12:0.9.4 \
  ;; -r bintray:scalacenter/releases \
  ;; -r sonatype:snapshots \
  ;; -o /usr/local/bin/metals-emacs -fafter scala-mode
    ;; :demand t
    ;; :hook (scala-mode . lsp)
    ;; :init (setq lsp-scala-server-command "~/bin/metals-emacs"))

  (use-package lsp-metals
    :config (setq lsp-metals-treeview-show-when-views-received t))

  (use-package lsp-ui)

  (setq lsp-ui-sideline-enable t)
  (setq lsp-ui-peek-enable t)

  ;; Debugging purposes
  (use-package dap-mode
    :hook
    (lsp-mode . dap-mode)
    (lsp-mode . dap-ui-mode)
    )

#+END_SRC 

#+RESULTS:
: t

* ESS
** Conffaus
#+BEGIN_SRC emacs-lisp

  (use-package ess
    :ensure t
    ;; :defer t ;; Pidä tässä kunnes keksit keinon toimia lokaalien key-chordien kanssa

    :init
    ;; (setq ess-use-auto-complete t)
    (setq ess-first-tab-never-complete 'unless-eol)
    (setq-default inferior-R-program-name "/usr/local/bin/R")
    (add-hook 'inferior-ess-mode-hook 'aseta-comint-liikkeet)
    (defun my-ess-hook ()
      ;; ensure company-R-library is in ESS backends
      (make-local-variable 'company-backends)
      (cl-delete-if (lambda (x) (and (eq (car-safe x) 'company-R-args))) company-backends)
      (push (list 'company-R-args 'company-R-objects 'company-R-library :separate
		  company-backends)))

    :hook my-ess-hook 

    )

#+END_SRC 

** Keychord
#+NAME: ess-keychord
#+BEGIN_SRC emacs-lisp :lexical t

  (key-chord-define ess-mode-map ",," (kirjoita " <- "))
  (key-chord-define ess-mode-map "yu" (kirjoita " %>% "))

#+END_SRC 
* Dired
#+BEGIN_SRC emacs-lisp :lexical t

  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
  (define-key dired-mode-map "åq" 'dired-toggle-read-only)
  (define-key wdired-mode-map "åq" 'wdired-exit)
  (define-key dired-mode-map "b" 'revert-buffer)
#+END_SRC 

* EDBI
#+BEGIN_SRC emacs-lisp :lexical t

  (use-package edbi
    :ensure t
    )

#+END_SRC 

* EmacSQL
#+BEGIN_SRC emacs-lisp :lexical t

  ;; (use-package emacsql
    ;; :ensure t
    ;; :defer t

    ;; :init
    ;; (use-package emacsql-sqlite
      ;; :ensure t
      ;; :defer t
      ;; :init
      ;; (require 'emacsql)
      ;; (require 'emacsql-sqlite)
      ;; (defvar tietokanta-polku "/Users/tommi/Tietokannat/")
      ;; (defun tietokanta-yhteys (filu) (emacsql-sqlite (concat tietokanta-polku filu)))
      ;; (setq db-jargon (tietokanta-yhteys "jargon.db"))
      ;; )
    ;; )

#+END_SRC 

* Markdown
#+BEGIN_SRC emacs-lisp :lexical t

  (setq markdown-css-paths `(,(expand-file-name "/Users/tommi/Css/markdown.css")))

#+END_SRC 

* Powerline
#+BEGIN_SRC emacs-lisp :lexical t

  ;; (use-package powerline-mode
      ;; :ensure t
      ;; :init (powerline-vim-theme))

#+END_SRC 

* Scala
#+BEGIN_SRC emacs-lisp :lexical t

  (use-package scala
    :defer t
    :init
    (add-hook 'scala-mode-hook
	    (lambda ()
	      (ammonite-term-repl-minor-mode t)
	      ;; (electric-pair-mode t)
	      ;; (smartparens-mode nil)
	      (company-mode t)))
    (setq scala-indent:indent-value-expression t)
    (setq ammonite-term-repl-auto-detect-predef-file nil)


    )

#+END_SRC 

* Palkki
#+BEGIN_SRC emacs-lisp :lexical t

  (defun meitsin-status-bar ()
    "Tämä näkyy bufferin alalaidassa."  
    (interactive)
    ;; Vaihda ensin taustaväri purppuraiseksi.
    (set-face-attribute 'mode-line nil
			:background "#660066"
			:foreground "White"
			:box nil)
    ;; Hoida tämän jälkeen itse informaatioiden asettelu kuntoon.
    (setq mode-line-format
      (list
	;; the buffer name; the file name as a tool tip
	'(:eval (propertize "%b " 'face 'font-lock-keyword-face
	    'help-echo (buffer-file-name)))

	;; line and column
	"(" ;; '%02' to set to 2 chars at least; prevents flickering
	  (propertize "%02l" 'face 'font-lock-type-face) ","
	  (propertize "%02c" 'face 'font-lock-type-face) 
	") "

	;; relative position, size of file (poissa käytöstä toistaiseksi)
	;; "["
	;; (propertize "%p" 'face 'font-lock-comment-face) ;; % above top
	;; "/"
	;; (propertize "%I" 'face 'font-lock-comment-face) ;; size
	;; "] "

	;; the current major mode for the buffer.
	"["

	'(:eval (propertize "%m" 'face 'font-lock-string-face
		  'help-echo buffer-file-coding-system))
	"] "



	"[" ;; insert vs overwrite mode, input-method in a tooltip
	'(:eval (propertize (if overwrite-mode "Ovr" "Ins")
		  'face 'font-lock-preprocessor-face
		  'help-echo (concat "Buffer is in "
			       (if overwrite-mode "overwrite" "insert") " mode")))

	;; was this buffer modified since the last save?
	'(:eval (when (buffer-modified-p)
		  (concat ","  (propertize "Mod"
				 'face 'font-lock-warning-face
				 'help-echo "Buffer has been modified"))))

	;; is this buffer read-only?
	'(:eval (when buffer-read-only
		  (concat ","  (propertize "RO"
				 'face 'font-lock-type-face
				 'help-echo "Buffer is read-only"))))  
	"] "

	'(:eval (concat (propertize "\xe928" ;  (python icon)
				    'face 'font-lock-type-face
				    'help-echo "Current virtualenvironment") 
			" [" conda-env-current-name "] "))


	;; Näytä sen hetkinen Git-branch
	'(vc-mode vc-mode)

	;; Kellonaikojen näyttö
	'(:eval (propertize (concat "  " (format-time-string "%a, %d.%m.%Y") ", klo " (format-time-string "%H:%M"))
		  'help-echo
		  (concat (format-time-string "%c; ")
			  (emacs-uptime "Uptime:%hh"))))


	;; add the time, with the date and the emacs uptime in the tooltip
	" --"
	;; i don't want to see minor-modes; but if you want, uncomment this:
	;; minor-mode-alist  ;; list of minor modes
	"%-" ;; fill with '-'
	)))

  (define-minor-mode palkki-mode
      "Näytä kustomoitu statusbar."
      :lighter "Palkki"
      :init-value nil
      )

  (add-hook 'palkki-mode-hook 'meitsin-status-bar)

  (define-global-minor-mode palkki-global-mode palkki-mode
      (lambda ()(interactive)(palkki-mode 1)))

  (palkki-global-mode)

#+END_SRC 

#+RESULTS:
: t

* Reddit
Käytä Redditiä Emacsin kautta.
#+BEGIN_SRC emacs-lisp

  (use-package md4rd 
    :ensure t
    :defer t
    :config
    (add-hook 'md4rd-mode-hook 'md4rd-indent-all-the-lines)
    (setq md4rd-subs-active '(emacs lisp+Common_Lisp prolog clojure))
    (setq md4rd--oauth-access-token
	  reddit-tokeni-client-id)
    (setq md4rd--oauth-refresh-token
	  reddit-tokeni-secret-id)
    (run-with-timer 0 3540 'md4rd-refresh-login))

#+END_SRC 

